<html>
<head>
	<meta charset="UTF-8">
	<script language="javascript" type="text/javascript" src="lib/p5.min.js"></script>
	<script language="javascript" type="text/javascript" src="graph.js"></script>
	<script language="javascript" type="text/javascript" src="planarGraph.js"></script>
	<script language="javascript" type="text/javascript" src="renderNS.js"></script>
	<style> 

	body {padding: 0; margin: 0;} 
	.third{
		width: 33%;
		display:inline-block;
	}
	.page{
		padding:2em;
	}
	.quote, .quoteauthor{
		text-align:center;
		font-style: italic;
	}
	.quoteauthor{
		font-weight: bold;
	}
	.centered{
		width: 100%;
		text-align: center;
	}
	h1{ font-size: 400%; }
	h2{ font-size: 320%; }
	h3{ font-size: 260%; }
	h4{ font-size: 200%; }
	h5{ font-size: 150%; }
	p{ font-size: 180%; }
    pre {
        font-family: "Courier 10 Pitch", Courier, monospace;
        font-size: 95%;
        line-height: 140%;
        white-space: pre;
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -o-pre-wrap;
    }       
    
    code {
        font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace;
        font-size: 95%;
        line-height: 140%;
        white-space: pre;
        white-space: pre-wrap;
        white-space: -moz-pre-wrap;
        white-space: -o-pre-wrap;
        background: #faf8f0;
    }
    
    #content code {
        display: block;
        padding: 0.5em 1em;
        border: 1px solid #bebab0;
    }
	</style>
</head>
<body>
<div class="page">
	<h1>Origami Crease Patterns</h1>
	<p>are <a href="https://en.wikipedia.org/wiki/Planar_graph">planar graphs</a>, which is a type of <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">mathematical graph</a>: a collection of edges defined by nodes (creases defined by endpoints).</p>
	<div id="containerIntro" class="centered"></div>
	<pre class="centered"><code>var graph = new Graph()
graph.fishBase()</code></pre>
	<h1>Planar Graph</h1>
	<p>The Planar Graph adds to the Graph the idea of 2D space. Now, it's possible to ask:</p>
	<p class="quote">"Do 2 lines cross over each other?"</p>
	<p>An infinite surface is possible, but ours is constrained to a unit square: with the origin (0,0) at one corner.</p>
	<h1>title 2</h1>
	<p>to keep things clean: if a bunch of lines cross at a point, those lines share the same point, there is nothing like "layers" of points at the same location on top of one another.</p>
	<div class="third" id="container0"></div><div class="third" id="container1"></div><div class="third" id="container2"></div>
	<pre class="centered"><code>
graph.addEdgeWithVertices(x1, y1, x2, y2)    //(float, float, float, float)
graph.addEdgeFromVertex(existingIndex, newX, newY)    //(uint, float, float)
graph.addEdgeRadiallyFromVertex(existingIndex, angle, distance)    //(uint, float, float)
	</pre></code>
	<h1>Intersections</h1>
	<div class="centered" id="container3"></div>
	<pre class="centered"><code>graph.getAllEdgeIntersections()</code></pre>
	<h1>Chopping</h1>
	<div class="centered" id="container4"></div>
	<p class="quote">press and hold</p>
	<pre class="centered"><code>graph.chopAtIntersections()</code></pre>
</div>
<script>

function fillWithRandom(graph, count){
	for(var i = 0; i < count; i++){
		graph.addEdgeWithVertices(Math.random(), Math.random(), Math.random(), Math.random());
	}
}
function fillWithSunburst(graph, count){
	var center = {x:0.5, y:0.5, z:0.0};
	graph.nodes.push(center);
	for(var i = 0; i < count; i++){
		graph.addEdgeFromVertex(0, Math.random(), Math.random());
	}
}
function fillWithRope(graph, count){
	var first = {x:Math.random(), y:Math.random(), z:0.0};
	graph.nodes.push(first);
	for(var i = 0; i < count; i++){
		graph.addEdgeFromVertex(i, Math.random(), Math.random());
	}
}

var s0 = function( p ) {
	var g = new PlanarGraph();
	var paperSize = 250;
	p.numLines = 3;
	p.reset = function(){
		g.clear();
		var select = Math.random();
		if(select < 0.25){
			g.kiteBase();
		}else if(select < 0.5){
			g.fishBase();
		}else if(select < 0.75){
			g.birdBase();
		}else {
			g.frogBase();
		}
		g.cleanup();
	}
	p.setup = function(){
		canvas = p.createCanvas(paperSize, paperSize);
		p.reset();
		// noLoop();
		// frameRate(10);
	}
	p.draw = function() {
		var mag = 0.005;
		var speed = 0.001;
		// update
		for(var i = 0; i < g.nodes.length; i++){
			var boundary = g.nodes[i].isBoundary;
			// console.log(boundary);
			if(boundary == undefined){
				// g.nodes[i].x += -0.0005 + 0.001 * p.noise(i*31.111+p.millis()*0.0002);
				// g.nodes[i].y += -0.0005 + 0.001 * p.noise(i*44.22+10+p.millis()*0.0002);
			} else if(boundary == 1 || boundary == 3){
				g.nodes[i].x += -mag*0.5 + mag * p.noise(i*31.111+p.millis()*speed);
			} else if(boundary == 2 || boundary == 4){
				g.nodes[i].y += -mag*0.5 + mag * p.noise(i*44.22+10+p.millis()*speed);
			}
			// g.nodes[i].x += -0.0005 + 0.001 * p.noise(i*31.111+p.millis()*0.0002);
			// g.nodes[i].y += -0.0005 + 0.001 * p.noise(i*44.22+10+p.millis()*0.0002);
			if(g.nodes[i].x < 0.0) g.nodes[i].x = 0.0;
			if(g.nodes[i].x > 1.0) g.nodes[i].x = 1.0;
			if(g.nodes[i].y < 0.0) g.nodes[i].y = 0.0;
			if(g.nodes[i].y > 1.0) g.nodes[i].y = 1.0;
		}

		// draw
		p.clear();
		p.applyMatrix(paperSize, 0, 0, paperSize, paperSize*0.5-paperSize*0.5, paperSize*0.5-paperSize*0.5);
		p.strokeWeight(.01);
		drawCoordinateFrame(p);
		// drawGraphPoints(p, g);
		drawGraphLines(p, g);
	}
	p.mousePressed = function(){
		p.reset();
	}
};

var s1 = function( p ) {
	var g = new PlanarGraph();
	var paperSize = 250;
	p.numLines = 20;
	p.pattern = 0;
	var intersections = [];
	p.reset = function(){
		g.clear();
		if(p.pattern == 2)
			fillWithRope(g, p.numLines);
		else if(p.pattern == 1)
			fillWithSunburst(g, p.numLines);
		else 
			fillWithRandom(g, p.numLines);
		if(p.showIntersections)
			intersections = g.getAllEdgeIntersections();
	}
	p.setup = function(){
		canvas = p.createCanvas(paperSize, paperSize);
		p.reset();
		// noLoop();
		// frameRate(10);
	}
	p.draw = function() {
		p.clear();
		p.applyMatrix(paperSize, 0, 0, paperSize, paperSize*0.5-paperSize*0.5, paperSize*0.5-paperSize*0.5);
		p.fill(0, 0, 0);
		p.stroke(0, 0, 0);
		p.strokeWeight(.01);
		drawCoordinateFrame(p);
		drawGraphPoints(p, g);
		drawGraphLines(p, g);
		// intersections
		p.fill(255, 0, 0);
		p.noStroke();
		for(var i = 0; i < intersections.length; i++){
			p.ellipse(intersections[i].x, intersections[i].y, .03, .03);
		}
	}
	p.mousePressed = function(){
		p.reset();
	}
};

var s3 = function( p ) {
	var g = new PlanarGraph();
	var paperSize = 250;
	p.numLines = 6;
	var intersections = [];
	p.reset = function(){
		g.clear();
		fillWithRope(g, p.numLines);
	}
	p.setup = function(){
		canvas = p.createCanvas(paperSize, paperSize);
		p.reset();
		// for(var i = 0; i < g.nodes.length; i++){
		// 	var boundary = g.nodes[i].isBoundary;
		// }
		// noLoop();
		// frameRate(10);
	}
	p.draw = function() {
		// update
		for(var i = 0; i < g.nodes.length; i++){
			g.nodes[i].x = p.noise(i*31.111+p.millis()*0.0002);
			g.nodes[i].y = p.noise(i*44.22+10+p.millis()*0.0002);
		}
		intersections = g.getAllEdgeIntersections();

		// draw
		p.clear();
		p.applyMatrix(paperSize, 0, 0, paperSize, paperSize*0.5-paperSize*0.5, paperSize*0.5-paperSize*0.5);
		p.fill(0, 0, 0);
		p.stroke(0, 0, 0);
		p.strokeWeight(.01);
		drawCoordinateFrame(p);
		drawGraphPoints(p, g);
		drawGraphLines(p, g);
		// intersections
		p.fill(255, 0, 0);
		p.noStroke();
		for(var i = 0; i < intersections.length; i++){
			p.ellipse(intersections[i].x, intersections[i].y, .03, .03);
		}
	}
	p.mousePressed = function(){
		// p.reset();
	}
};

var s4 = function( p ){

	var g = new PlanarGraph();
	var paperSize = 250;
	var intersections = [];
	var bounds = [
		{xmin:0.0, xmax:0.33, ymin:0.0, ymax:0.33},
		{xmin:0.66, xmax:1.0, ymin:0.66, ymax:1.0},
		{xmin:0.66, xmax:1.0, ymin:0.0, ymax:0.33},
		{xmin:0.0, xmax:0.33, ymin:0.66, ymax:1.0},
		{xmin:0.0, xmax:1.0, ymin:0.0, ymax:1.0}
	];

	function drawAnX(graph){
		graph.clear();
		var w = 0.33;
		var first = {x:Math.random()*w, y:Math.random()*w, z:0.0};
		graph.nodes.push(first);
		graph.addEdgeFromVertex(0, Math.random()*w+(1-w), Math.random()*w+(1-w));
		var second = {x:Math.random()*w, y:Math.random()*w+(1-w), z:0.0};
		graph.nodes.push(second);
		graph.addEdgeFromVertex(2, Math.random()*w+(1-w), Math.random()*w);
	}

	function reset(){
		g.edges = [];
		g.nodes.pop();
		g.addEdgeFromExistingVertices(0, 1);
		g.addEdgeFromExistingVertices(2, 3);
		intersections = g.getAllEdgeIntersections();
	}

	p.setup = function(){
		canvas = p.createCanvas(paperSize, paperSize);
		p.strokeWeight(.01);
		drawAnX(g);
	}

	function chop(){
		// we're going to be iterating and removing elements at the same time (!)
		// we will remove edges. we only add to nodes array. nodes indices are preserved.
		var intersections = g.getAllEdgeIntersectionsDetailed();
		for(var i = 0; i < intersections.length; i++){
			var node1a = intersections[i]['edge1NodeA'];
			var node1b = intersections[i]['edge1NodeB'];
			var node2a = intersections[i]['edge2NodeA'];
			var node2b = intersections[i]['edge2NodeB'];
			var intersection = intersections[i].location;

			g.removeEdgeBetween(node1a, node1b);
			g.removeEdgeBetween(node2a, node2b);
			var newIntersectionVertexIndex = g.nodes.length;
			g.addEdgeFromVertex(node1a, intersection.x, intersection.y);
			g.addEdgeFromExistingVertices(node1b, newIntersectionVertexIndex);
			g.addEdgeFromExistingVertices(node2a, newIntersectionVertexIndex);
			g.addEdgeFromExistingVertices(node2b, newIntersectionVertexIndex);
		}
	}

	p.draw = function() {

		// update
		for(var i = 0; i < g.nodes.length; i++){
			var speed = 0.002;
			var mag = 0.02;
			var mult1 = Math.pow(i*2, 1.5);
			var mult2 = Math.pow(i*2.3, 1.333);
			g.nodes[i].x += -mag*0.5 + mag * p.noise(i*mult1+1.3*(i+1)+p.millis()*speed);
			g.nodes[i].y += -mag*0.5 + mag * p.noise(i*mult2+5*(i+1)+p.millis()*speed);
			if(g.nodes[i].x < bounds[i].xmin) g.nodes[i].x = bounds[i].xmin;
			if(g.nodes[i].x > bounds[i].xmax) g.nodes[i].x = bounds[i].xmax;
			if(g.nodes[i].y < bounds[i].ymin) g.nodes[i].y = bounds[i].ymin;
			if(g.nodes[i].y > bounds[i].ymax) g.nodes[i].y = bounds[i].ymax;
		}
		intersections = g.getAllEdgeIntersections();
		
		// draw
		p.clear();
		p.applyMatrix(paperSize, 0, 0, paperSize, paperSize*0.5-paperSize*0.5, paperSize*0.5-paperSize*0.5);
		
		p.fill(0, 0, 0);
		p.stroke(0, 0, 0);
		drawCoordinateFrame(p);
		drawGraphPoints(p, g);
		drawGraphLines(p, g);
		for(var i = 0; i < intersections.length; i++){
			p.fill(255, 0, 0);
			p.noStroke();
			p.ellipse(intersections[i].x, intersections[i].y, .03, .03);
		}
	}

	p.mouseReleased = function(){
		reset();	
	}

	p.mousePressed = function(){
		chop();
	}	
}


var myp5 = new p5(s0, 'containerIntro');
var myp5 = new p5(s1, 'container0');
myp5.pattern = 0;
var myp5 = new p5(s1, 'container1');
myp5.pattern = 1;
var myp5 = new p5(s1, 'container2');
myp5.pattern = 2;
var myp5 = new p5(s3, 'container3');
var myp5 = new p5(s4, 'container4');

</script>

</body>
</html>