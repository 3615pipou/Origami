<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,
body {
	margin: 0;
	overflow: hidden;
	height: 100%;
}
/* Scale canvas with resize attribute to full size */
canvas[resize] {
	width: 100%;
	height: 100%;
}
</style>
<script type="text/javascript" src="../src/graph.js"></script>
<script type="text/javascript" src="../src/planarGraph.js"></script>
<script type="text/javascript" src="../src/creasePattern.js"></script>
<script type="text/javascript" src="../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../lib/perlin.js"></script>
<script>

var cp = new CreasePattern();
// cp.generateFaces();
cp.addEdgeWithVertices(0, 0, 0, 1);
cp.addEdgeWithVertices(0, 1, 1, 1);
cp.addEdgeWithVertices(1, 1, 1, 0);
cp.addEdgeWithVertices(1, 0, 0, 0);
for(var i = 0; i < 80; i++){
	cp.addEdgeWithVertices(Math.random(), Math.random(), Math.random(), Math.random());
}
var paperPoints = [];
var paperEdges = [];
var intersections = [];
var rayCenter = new XYPoint(0.5, 0.5);
var rayDirection = new XYPoint(1.0, 0.0);

</script>
<script type="text/paperscript" canvas="canvas">

var children = project.activeLayer.children;
var lineWeight = 4;
var paperSize;

var center = view.center;

console.log(cp);

var cpLayer = new Layer();
var intersectionLayer = new Layer();

function borderPath(){
	return new Path({
		strokeColor: { hue:0, saturation:1, brightness:0 },
		strokeWidth: lineWeight,
		closed: false
	});
}

function copyCPToPaperJS(){
	cpLayer.activate();

	center = view.center;
	var paperWindowScale = 0.8;
	if(window.innerWidth < window.innerHeight){ paperSize = window.innerWidth * paperWindowScale;
	} else{ paperSize = window.innerHeight * paperWindowScale; }

	project.activeLayer.removeChildren();
	paperPoints = [];
	paperEdges = [];

	for(var i = 0; i < cp.nodes.length; i++){
		var p = new Point(cp.nodes[ i ].x, cp.nodes[ i ].y) * paperSize + center - paperSize * 0.5;
		paperPoints.push( p );
	}
	for(var i = 0; i < cp.edges.length; i++){
		var path = borderPath();
		path.segments = [ paperPoints[cp.edges[i].node[0] ], paperPoints[cp.edges[i].node[1] ] ];
		paperEdges.push( path );
	}
}

copyCPToPaperJS();

function updateCPToPaperJS(){
	cpLayer.activate();
	
	center = view.center;
	var paperWindowScale = 0.8;
	if(window.innerWidth < window.innerHeight){ paperSize = window.innerWidth * paperWindowScale;
	} else{ paperSize = window.innerHeight * paperWindowScale; }
	for(var i = 0; i < cp.nodes.length; i++){
		paperPoints[i].x = cp.nodes[i].x * paperSize + center.x - paperSize * 0.5;
		paperPoints[i].y = cp.nodes[i].y * paperSize + center.y - paperSize * 0.5;
	}
	for(var i = 0; i < cp.edges.length; i++){
		paperEdges[i].segments[0].point = paperPoints[ cp.edges[i].node[0] ];
		paperEdges[i].segments[1].point = paperPoints[ cp.edges[i].node[1] ];
	}
}

function onFrame(event) {
	updateCPToPaperJS();

	intersectionLayer.activate();
	intersectionLayer.removeChildren();

	intersections = [];
	rayDirection = new XYPoint(Math.cos(event.time), Math.sin(event.time));
	for(var i = 0; i < cp.edges.length; i++){
		var endPoints = cp.edges[i].endPoints();
		var intersection = rayLineSegmentIntersectionAlgorithm(rayCenter, rayDirection, endPoints[0], endPoints[1]);
		if(intersection != undefined){
			intersections.push(intersection);
			var shape = new Shape.Circle(new Point(intersection.x * paperSize + center.x - paperSize * 0.5, intersection.y * paperSize + center.y - paperSize * 0.5), 4);
			//shape.strokeColor = 'black';
			shape.fillColor = 'red';
		}
	}
}

function onResize(event) {
	updateCPToPaperJS();
}

function onMouseMove(event) {
	mousePos = event.point;
}

</script>
</head>
<body style="background:white">
	<canvas id="canvas" resize></canvas>
</body>
</html>
