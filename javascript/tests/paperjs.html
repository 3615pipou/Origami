<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,
body {
	margin: 0;
	overflow: hidden;
	height: 100%;
}
/* Scale canvas with resize attribute to full size */
canvas[resize] {
	width: 100%;
	height: 100%;
}
</style>
<script type="text/javascript" src="../src/graph.js"></script>
<script type="text/javascript" src="../src/planarGraph.js"></script>
<script type="text/javascript" src="../src/creasePattern.js"></script>
<script type="text/javascript" src="../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../lib/perlin.js"></script>
<script>

var cp = new CreasePattern();
// cp.frogBase();
cp.fishBase();
// cp.generateFaces();
var paperPoints = [];
var paperEdges = [];
var paperFaces = [];

</script>
<script type="text/paperscript" canvas="canvas">

var children = project.activeLayer.children;
var nearestEdge = undefined;
var lineWeight = 4;
var paperSize;

var wobble2 = {x:cp.nodes[2].x, y:cp.nodes[2].y};
var wobble3 = {x:cp.nodes[3].x, y:cp.nodes[3].y};

var center = view.center;

console.log(cp);

function mountainPath(){
	return new Path({
		strokeColor: { hue:350, saturation:1, brightness:1 },
		strokeWidth: lineWeight,
		closed: false
	});
}
function valleyPath(){
	return new Path({
		strokeColor: { hue:230, saturation:1, brightness:1 },
		dashArray: [lineWeight, lineWeight],
		strokeWidth: lineWeight,
		closed: false
	});
}
function borderPath(){
	return new Path({
		strokeColor: { hue:0, saturation:1, brightness:0 },
		strokeWidth: lineWeight,
		closed: false
	});
}

function copyCPToPaperJS(){

	center = view.center;
	var paperWindowScale = 0.8;
	if(window.innerWidth < window.innerHeight){ paperSize = window.innerWidth * paperWindowScale;
	} else{ paperSize = window.innerHeight * paperWindowScale; }

	project.activeLayer.removeChildren();
	paperPoints = [];
	paperEdges = [];
	paperFaces = [];

	for(var i = 0; i < cp.nodes.length; i++){
		var p = new Point(cp.nodes[ i ].x, cp.nodes[ i ].y) * paperSize + center - paperSize * 0.5;
		paperPoints.push( p );
	}
	for(var i = 0; i < cp.edges.length; i++){
		var path;
		if(     cp.edges[i].orientation == CreaseDirection.mountain){ path = mountainPath(); }
		else if(cp.edges[i].orientation == CreaseDirection.valley){ path = valleyPath(); }
		else { path = borderPath(); }
		path.segments = [ paperPoints[cp.edges[i].node[0] ], paperPoints[cp.edges[i].node[1] ] ];
		paperEdges.push( path );
	}
	for(var i = 0; i < cp.faces.length; i++){
		var faceNodeArray = cp.faces[i].nodes;
		var segmentArray = [];
		for(var j = 0; j < faceNodeArray.length; j++){
			segmentArray.push( paperPoints[ faceNodeArray[j].index ] );
		}
		paperFaces.push(new Path({
//				fillColor: { hue:120, saturation:.8, brightness:.8 },
//				fillColor: { red:0.0, green:0.0, blue:0.0, alpha:0.2 },
				fillColor: { gray:0.0, alpha:0.1 },
				segments: segmentArray,
				closed: true
			}) );
	}
}

function incenter(pointArray){
	var xSum = 0;
	var ySum = 0;
	var p = 0;
	for(var i = 0; i < pointArray.length; i++){
		var nextI = (i+1) % pointArray.length;
		var nextnextI = (i+2) % pointArray.length;
		var oLX = pointArray[nextI].x - pointArray[nextnextI].x;
		var oLY = pointArray[nextI].y - pointArray[nextnextI].y;
		var d = Math.sqrt(oLX*oLX + oLY*oLY);
		xSum += pointArray[i].x * d;
		ySum += pointArray[i].y * d;
		p += d;
	}
	return new Point(xSum / p, ySum / p);
}

function centroid(pointArray){
	if(pointArray.length == 0) return new Point();
	var xSum = 0;
	var ySum = 0;
	for(var i = 0; i < pointArray.length; i++){
		xSum += pointArray[i].x;
		ySum += pointArray[i].y;
	}
	return new Point(xSum/pointArray.length, ySum/pointArray.length);
}

copyCPToPaperJS();

function updateCPToPaperJS(){
	center = view.center;
	var paperWindowScale = 0.8;
	if(window.innerWidth < window.innerHeight){ paperSize = window.innerWidth * paperWindowScale;
	} else{ paperSize = window.innerHeight * paperWindowScale; }

	for(var i = 0; i < cp.nodes.length; i++){
		paperPoints[i].x = cp.nodes[i].x * paperSize + center.x - paperSize * 0.5;
		paperPoints[i].y = cp.nodes[i].y * paperSize + center.y - paperSize * 0.5;
	}
	for(var i = 0; i < cp.edges.length; i++){
		paperEdges[i].segments[0].point = paperPoints[ cp.edges[i].node[0] ];
		paperEdges[i].segments[1].point = paperPoints[ cp.edges[i].node[1] ];
	}
	for(var i = 0; i < cp.faces.length; i++){
		var faceNodeArray = cp.faces[i].nodes;
		var segmentArray = [];
		for(var j = 0; j < faceNodeArray.length; j++){
			segmentArray.push( paperPoints[ faceNodeArray[j].index ] );
			paperFaces[i].segments[j].point = paperPoints[ faceNodeArray[j].index ];
		}
		var center;
		if(faceNodeArray.length == 3){ center = incenter(segmentArray); } 
		else{                      center = centroid(segmentArray); }
		paperFaces[i].scale(0.5, center);
	}
}

function onFrame(event) {
	var scale = .04;
	var sp = 1.5;
	cp.nodes[2].x = wobble2.x + Math.sin(sp*event.time*.8) * scale
	cp.nodes[2].y = wobble2.y + Math.cos(sp*event.time*.895) * scale;
	cp.nodes[3].x = wobble3.x + Math.sin(sp*event.time*1.2) * scale;
	cp.nodes[3].y = wobble3.y + Math.sin(sp*event.time) * scale;

	updateCPToPaperJS();
}

function onResize(event) {
	updateCPToPaperJS();
}

function onMouseMove(event) {
	mousePos = event.point;
	nearestEdge = cp.getNearestEdge( (mousePos.x - center.x + paperSize * 0.5) / paperSize , 
									 (mousePos.y - center.y + paperSize * 0.5) / paperSize  ).edge;
	for(var i = 0; i < cp.edges.length; i++){
		var weight = 3;
		if(nearestEdge != undefined && nearestEdge == i){
			paperEdges[i].strokeWidth = lineWeight+2;
		} else{
			paperEdges[i].strokeWidth = lineWeight;
		}
	}
}

</script>
</head>
<body style="background:white">
	<canvas id="canvas" resize></canvas>
</body>
</html>
