<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
html,
body {
	margin: 0;
	overflow: hidden;
	height: 100%;
}
/* Scale canvas with resize attribute to full size */
canvas[resize] {
	width: 100%;
	height: 100%;
}
</style>
<script type="text/javascript" src="../../../src/graph.js"></script>
<script type="text/javascript" src="../../../src/planarGraph.js"></script>
<script type="text/javascript" src="../../../src/creasePattern.js"></script>
<script type="text/javascript" src="../../../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../../paperjs.cp.js"></script>
<script type="text/javascript" src="../../../lib/perlin.js"></script>
<script>

function incenter(pointArray){
	var xSum = 0, ySum = 0, p = 0;
	for(var i = 0; i < pointArray.length; i++){
		var nextI = (i+1) % pointArray.length;
		var nextnextI = (i+2) % pointArray.length;
		var oLX = pointArray[nextI].x - pointArray[nextnextI].x;
		var oLY = pointArray[nextI].y - pointArray[nextnextI].y;
		var d = Math.sqrt(oLX*oLX + oLY*oLY);
		xSum += pointArray[i].x * d;
		ySum += pointArray[i].y * d;
		p += d;
	}
	return new paper.Point(xSum / p, ySum / p);
}

function centroid(pointArray){
	if(pointArray.length == 0) return new paper.Point();
	var xSum = 0, ySum = 0;
	for(var i = 0; i < pointArray.length; i++){
		xSum += pointArray[i].x;
		ySum += pointArray[i].y;
	}
	return new paper.Point(xSum/pointArray.length, ySum/pointArray.length);
}

window.onload = function() {

	var cp = new CreasePattern();
	// cp.frogBase();
	cp.fishBase();
	// cp.generateFaces();
	console.log(cp);

	var canvas = document.getElementById('canvas');
	// Create an empty project and a view for the canvas:
	paper.setup(canvas);
	zoomView(paper);

	var paperCP = new PaperCreasePattern(paper, cp);
	console.log(paperCP);

	var wobble2 = {x:cp.nodes[4].x, y:cp.nodes[4].y};
	var wobble3 = {x:cp.nodes[5].x, y:cp.nodes[5].y};

	paper.view.onFrame = function(event) {
		var scale = .04;
		var sp = 1.5;
		cp.nodes[4].x = wobble2.x + Math.sin(sp*event.time*.8) * scale
		cp.nodes[4].y = wobble2.y + Math.cos(sp*event.time*.895) * scale;
		cp.nodes[5].x = wobble3.x + Math.sin(sp*event.time*1.2) * scale;
		cp.nodes[5].y = wobble3.y + Math.sin(sp*event.time) * scale;

		paperCP.update();
		// shrink faces, use incenter if face is triangle
		for(var i = 0; i < paperCP.faces.length; i++){
			var facePoints = [];
			for(var j = 0; j < paperCP.faces[i].segments.length; j++){
				facePoints.push(paperCP.faces[i].segments[j].point);
			}
			var faceCenter;
			if(facePoints.length == 3){ faceCenter = incenter(facePoints); } 
			else                      { faceCenter = centroid(facePoints); }
			paperCP.faces[i].scale(0.8, faceCenter);
		}		
	}

	paper.view.onResize = function(event) {
		zoomView(paper);
	}

	paper.view.onMouseMove = function(event) {
		mousePos = event.point;
		var nearestEdge = cp.getNearestEdge( mousePos.x, mousePos.y ).edge;
		for(var i = 0; i < cp.edges.length; i++){
			var weight = 3;
			if(nearestEdge != undefined && nearestEdge == i){
				paperCP.edges[i].strokeWidth = paperCP.lineWeight*2;
			} else{
				paperCP.edges[i].strokeWidth = paperCP.lineWeight;
			}
		}
	}

//	paper.view.draw();
}

</script>
</head>
<body>
	<canvas id="canvas" resize></canvas>
</body>
</html>
