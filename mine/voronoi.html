<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link href="../lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<style>
html, body {
	height:100%;
	width:100%;
	background-color: #EEE;
	margin:0px;
}
canvas[resize]{
	width:100%;
	height:86%;
}
</style>
</head>
<body>
	<canvas id="canvas" resize></canvas>
	<input type="file" id="files" style="display:none;">
	<div style="text-align:center;">
		<a href="#" class="btn btn-lg btn-secondary" id="crease-button">Crease</a>
		<a href="#" class="btn btn-lg btn-secondary" id="download-file">Download</a>
	</div>
</body>

<script type="text/javascript" src="../lib/d3.min.js"></script>
<script type="text/javascript" src="../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../src/graph.js"></script>
<script type="text/javascript" src="../src/planarGraph.js"></script>
<script type="text/javascript" src="../src/creasePattern.js"></script>
<script type="text/javascript" src="../src/cp.paperjs.js"></script>
<script src="../lib/bootstrap/js/tether.min.js"></script>
<script src="../lib/jquery-3.2.1.slim.min.js"></script>
<script src="../lib/bootstrap/js/popper.min.js"></script>
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
<script src="../lib/bootstrap/js/ie10-viewport-bug-workaround.js"></script>

<script>
var showCreases = true;
document.getElementById("crease-button").addEventListener("click", function(e){
	e.preventDefault();
	// var checked = $(this).prop('checked');
	// showCreases = checked;
	// console.log($(this).prop('checked'));
	// project.makeVoronoi(touchNodes, 0.5, !showCreases);

	// var scale = 600 / project.cpMin;
	// var svgBlob = project.cp.svg(scale);
	// download(svgBlob, "creasepattern.svg");
	var v = project.makeVoronoi(touchNodes, 0.5, true);

});

</script>

<!-- download svg blob -->
<script>
document.getElementById("download-file").addEventListener("click", function(e){
	e.preventDefault();
	var scale = 600 / project.cpMin;
	var svgBlob = project.cp.svg(scale);
	download(svgBlob, "creasepattern.svg");
});
function download(text, filename){
	var blob = new Blob([text], {type: "image/svg+xml"});
	var url = window.URL.createObjectURL(blob);
	var a = document.createElement("a");
	a.href = url;
	a.download = filename;
	a.click();
}
</script>

<script type="text/javascript">
var voronoiAlgorithm; // global D3 algorithm implementation

var project = new OrigamiPaper("canvas");
project.updateWeights(0.005, 0.0025);
project.setPadding();
project.updateWeights(0.005, 0.0025);

var touchNodes = new PlanarGraph();
var touchNodesCircles = [];
var touchNodesLayer

var dragOn = false;
var selectedNode = undefined;

project.makeVoronoi = function(input, interpolation, gussets){
	var nodes = input.nodes.map(function(el){return el.values();});
	var v = voronoiAlgorithm( nodes );
	this.cp.clear();
	this.cp.nodes = [];
	this.cp.edges = [];
	this.cp.voronoiSimple(v, interpolation);
	if(gussets === false){
		for(var i = this.cp.edges.length-1; i >= 0; i--){
			// if(this.cp.edges[i].orientation !== CreaseDirection.valley){
			if(this.cp.edges[i].orientation === CreaseDirection.mark || 
			   this.cp.edges[i].orientation === CreaseDirection.mountain){
				this.cp.removeEdge(this.cp.edges[i]);
			}
		}
	}
	this.updateWeights(0.005, 0.0025);
	this.draw();
	touchNodesLayer.activate();
	touchNodesLayer.removeChildren();
	touchNodesCircles = [];
	for(var i = 0; i < touchNodes.nodes.length; i++){
		var nodeCircle = new this.scope.Shape.Circle({ radius: 0.0025, fillColor:this.style.valley.strokeColor});
		touchNodesCircles.push(nodeCircle);
		nodeCircle.position = touchNodes.nodes[i];
	}
	return v;
}

// project.setup = function(){
// 
// }

// project.draw = function(){
// }

// project.setup();
// var drawLoop = setInterval(project.draw, 1000/60);



project.reset = function(){
	this.cp.clear();
	this.cp.rectangle(1.3,1);
	this.draw();
	var bounds = this.cp.bounds();
	var boundingBoxD3 = [[bounds.topLeft.x, bounds.topLeft.y],[bounds.size.width, bounds.size.height]];
	voronoiAlgorithm = d3.voronoi().extent( boundingBoxD3 );

	if(touchNodesLayer !== undefined){ touchNodesLayer.removeChildren(); }
	touchNodesLayer = new this.scope.Layer();

	// var numdots = Math.PI*20;
	// add to voronoi
	// for(var i = -10; i < numdots+10; i++){
	// 	var freq = Math.PI*2 * (i/numdots)  * 0.5;  //0.5
	// 	var freq2 = Math.PI*2 * (i/numdots) * 3;  //4
	// 	var x = (i/numdots) + Math.cos(freq2)*0.2;
	// 	var y = map(Math.cos(freq), -1, 1, .1, .9) + Math.sin(freq2)*0.2;
	// 	if(x <= 1 && x >= 0 && y >= 0 && y <= 1){
	// 		touchNodes.newPlanarNode(x, y);
	// 	}
	// }

	// simple example

	// touchNodes.newPlanarNode(0.6, 0.15);
	// touchNodes.newPlanarNode(0.6, 0.85);
	// touchNodes.newPlanarNode(0.8, 0.5);

	// medium example

	// touchNodes.newPlanarNode(0.8895643, 0.64559477);
	// touchNodes.newPlanarNode(0.63182229, 0.93481682);
	// touchNodes.newPlanarNode(0.90136937, 0.31899028);
	// touchNodes.newPlanarNode(0.79905953, 0.0179632);

	// challenging example

	// touchNodes.newPlanarNode(0.867921, 0.712489);
	// touchNodes.newPlanarNode(0.781352, 0.891531);
	// touchNodes.newPlanarNode(0.885629, 0.517707);
	// touchNodes.newPlanarNode(0.836441, 0.303250);
	// touchNodes.newPlanarNode(0.742002, 0.128143);
	// touchNodes.newPlanarNode(0.657399, 0.017963);

	// for(var i = 0; i < numdots+30; i++){
	// 	var freq = Math.PI*2 * (i/numdots * .5);  //0.5
	// 	var freq2 = Math.PI*2 * (i/numdots * Math.PI);  //4
	// 	var x = (i/numdots) + Math.cos(freq2)*0.1;
	// 	var y = map(Math.cos(freq), -1, 1, .1, .9) + Math.sin(freq2)*0.1;
	// 	if(x <= 1 && x >= 0 && y >= 0 && y <= 1){
	// 		touchNodes.newPlanarNode(x, y);
	// 	}
	// }
	var v = this.makeVoronoi(touchNodes, 0.5, false);
}
project.reset();

project.onResize = function(){
	var bounds = this.cp.bounds();
	var boundingBoxD3 = [[bounds.topLeft.x, bounds.topLeft.y],[bounds.size.width, bounds.size.height]];
	voronoiAlgorithm = d3.voronoi().extent( boundingBoxD3 );
}

project.onMouseDown = function(event){
	// mouse change
	// numdots = Math.floor(event.point.x * 10 + 1);
	// console.log(numdots);
	// this.reset();

	var v;

	if(selectedNode === undefined){
		if(this.cp.pointInside(event.point)){ 
			touchNodes.newPlanarNode(event.point.x, event.point.y); 
			v = this.makeVoronoi(touchNodes, 0.5, false);
			selectedNode = undefined;
			for(var i = 0; i < touchNodes.nodes.length; i++){
				if(touchNodesCircles[i] !== undefined){
					var d = touchNodes.nodes[i].distanceTo(event.point);
					if(d < 0.01){ touchNodesCircles[i].radius = 0.005; selectedNode = i;}
					else        { touchNodesCircles[i].radius = 0.0025; }
				}
			}
			dragOn = true;
		}
	} else{
		v = this.makeVoronoi(touchNodes, 0.5, false);
		dragOn = true;
	}
}
project.onMouseUp = function(event){ 
	dragOn = false;
}
project.onMouseMove = function(event) {

	var mouse = event.point;
	if(dragOn){
		touchNodes.nodes[selectedNode].x = mouse.x;
		touchNodes.nodes[selectedNode].y = mouse.y;
		// var nodeCircle = touchNodesCircles[selectedNode];
		// if(nodeCircle !== undefined){
		// 	nodeCircle.position = event.point;
		// }
		if(!this.cp.contains(mouse.x, mouse.y)){
			dragOn = false;
			touchNodes.nodes.splice(selectedNode,1);
		}
		var v = this.makeVoronoi(touchNodes, 0.5, false);
	} else{
		selectedNode = undefined;
		for(var i = 0; i < touchNodes.nodes.length; i++){
			if(touchNodesCircles[i] !== undefined){
				var d = touchNodes.nodes[i].distanceTo(event.point);
				if(d < 0.01){ touchNodesCircles[i].radius = 0.005; selectedNode = i;}
				else        { touchNodesCircles[i].radius = 0.0025; }
			}
		}
	}
}
project.onFrame = function(event){ }

</script>

</html>