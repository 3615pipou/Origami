<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link href="../lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<style>
html, body {
	height:100%;
	width:100%;
	background-color: #EEE;
	margin:0px;
}
canvas[resize]{
	width:100%;
	height:86%;
}
</style>
</head>
<body>
	<canvas id="canvas" resize></canvas>
	<input type="file" id="files" style="display:none;">
	<div style="text-align:center;">
		<div class="btn-group" data-toggle="buttons">
			<label class="btn btn-lg btn-outline-secondary active">
				<input type="checkbox" id="show-creases-button" checked autocomplete="off"> Show Creases
			</label>
		</div>
		<a href="#" class="btn btn-lg btn-secondary" id="download-file">Download</a>
	</div>
</body>

<script type="text/javascript" src="../lib/d3.min.js"></script>
<script type="text/javascript" src="../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../src/graph.js"></script>
<script type="text/javascript" src="../src/planarGraph.js"></script>
<script type="text/javascript" src="../src/creasePattern.js"></script>
<script type="text/javascript" src="../src/cp.paperjs.js"></script>
<script src="../lib/bootstrap/js/tether.min.js"></script>
<script src="../lib/jquery-3.2.1.slim.min.js"></script>
<script src="../lib/bootstrap/js/popper.min.js"></script>
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
<script src="../lib/bootstrap/js/ie10-viewport-bug-workaround.js"></script>

<script>
var showCreases = true;
$('#show-creases-button').change(function() {
	var checked = $(this).prop('checked');
	showCreases = checked;
	console.log($(this).prop('checked'));
	project.makeVoronoi(touchNodes, 0.5, !showCreases);
})
</script>

<!-- download svg blob -->
<script>
document.getElementById("download-file").addEventListener("click", function(e){
	e.preventDefault();
	var scale = 600 / project.cpMin;
	var svgBlob = project.cp.svg(scale);
	download(svgBlob, "creasepattern.svg");
});
function download(text, filename){
	var blob = new Blob([text], {type: "image/svg+xml"});
	var url = window.URL.createObjectURL(blob);
	var a = document.createElement("a");
	a.href = url;
	a.download = filename;
	a.click();
}
</script>

<script type="text/javascript">
var voronoiAlgorithm; // global D3 algorithm implementation



var project = new OrigamiPaper("canvas");
project.updateWeights(0.005, 0.0025);
project.zoomToFit(0.02);

project.style.mountain.strokeColor = {gray:0.0, alpha:1.0};
project.style.valley.strokeColor = {gray:0.0, alpha:1.0};

var touchNodes = new PlanarGraph();
var touchNodesCircles = [];
var touchNodesLayer

var dragOn = false;
var selectedNode = undefined;

project.makeVoronoi = function(input, interpolation, hideCreaseMarks){
	var nodes = input.nodes.map(function(el){return el.values();});
	var v = voronoiAlgorithm( nodes );
	this.cp.clear();
	this.cp.nodes = [];
	this.cp.edges = [];
	this.cp.voronoiSimple(v, interpolation);
	if(hideCreaseMarks === true){
		for(var i = this.cp.edges.length-1; i >= 0; i--){
			// if(this.cp.edges[i].orientation !== CreaseDirection.valley){
			if(this.cp.edges[i].orientation === CreaseDirection.mark || 
			   this.cp.edges[i].orientation === CreaseDirection.mountain){
				this.cp.removeEdge(this.cp.edges[i]);
			}
		}
	}
	this.updateWeights(0.008, 0.004);
	this.init();
	touchNodesLayer.activate();
	touchNodesLayer.removeChildren();
	// faces
	var cells = voronoiAlgorithm.polygons(nodes);
	for(var c = 0; c < cells.length; c++){
		var segments = [];
		for(var e = 0; e < cells[c].length; e++){
			var point = new XY(cells[c][e][0], cells[c][e][1]);
			segments.push(point);
		}
		var face = new this.scope.Path({segments:segments,closed:true});
		var color = 100 + 200 * c/cells.length;
		face.fillColor = {gray:0.0, alpha:0.05};
		var site = new XY(cells[c].data[0], cells[c].data[1]);
		face.scale(.5, site);
	}

	// site nodes
	touchNodesCircles = [];
	for(var i = 0; i < touchNodes.nodes.length; i++){
		var nodeColor = {gray:0.0, alpha:1.0};//this.style.valley.strokeColor;
		var nodeCircle = new this.scope.Shape.Circle({ radius: 0.008, fillColor:nodeColor});
		touchNodesCircles.push(nodeCircle);
		nodeCircle.position = touchNodes.nodes[i];
	}
	return v;
}

project.reset = function(){
	this.cp.clear();
	// this.cp.rectangle(1.3,1);
	this.init();
	voronoiAlgorithm = d3.voronoi().extent( this.cp.boundingBox_array() );

	if(touchNodesLayer !== undefined){ touchNodesLayer.removeChildren(); }
	touchNodesLayer = new this.scope.Layer();

	for(var i = 0; i < 3; i++){
		touchNodes.newPlanarNode(Math.random(), Math.random());
	}

	var v = this.makeVoronoi(touchNodes, 0.5, !showCreases);
	console.log(v);
}
project.reset();

project.onResize = function(){
	voronoiAlgorithm = d3.voronoi().extent( this.cp.boundingBox_array() );
}

project.onMouseDown = function(event){
}
project.onMouseUp = function(event){ 
}
project.onMouseMove = function(event) {
}
project.onFrame = function(event){ 
	// console.log(event.time);
	for (var i = 0; i < touchNodes.nodes.length; i++){


		// touchNodes.nodes[i].x = circles[i].bodies[0].position.x;
		// touchNodes.nodes[i].y = circles[i].bodies[0].position.y;

		// touchNodes.nodes[i].x = (Math.sin(event.time*(Math.sin(i*3/2+Math.sin(i+2))*0.5+0.5) + Math.PI * 5/8))*0.5 + 0.5;
		// touchNodes.nodes[i].y = (Math.sin(event.time/12*3*(Math.sin(i*5/4+Math.sin(i+2))*0.5+0.5) + 1/12*Math.PI + 12/4))*0.5 + 0.5;
		var iPct = i / touchNodes.nodes.length;
		var iPctPi = i / touchNodes.nodes.length * Math.PI*2;

		var phase = .6*Math.sin(iPctPi+event.time);
		var off = 0.8 + 0.2*Math.sin(event.time) + 0.2*Math.cos(event.time*7/11);
		var innerPhase = event.time*1/5;
		var innerMag = 0.55;//1.85;
		var innerOff = 0.6 + 0.4*Math.sin(event.time*0.5);
		// var ininMag = 0.3;
		// var ininPhase = event.time*0.4 + iPctPi;

		touchNodes.nodes[i].x = 0.5+0.45*Math.cos(iPctPi+off + phase + innerMag*Math.sin(iPctPi*innerOff + innerPhase));// + ininMag*Math.sin(ininPhase));
		touchNodes.nodes[i].y = 0.5+0.45*Math.sin(iPctPi+off + phase + innerMag*Math.sin(iPctPi*innerOff + innerPhase));// + ininMag*Math.sin(ininPhase));

		// touchNodes.nodes[i].x = Math.cos(i+event.time*Math.cos(iPct*3/2 + 0.1*iPct*3/2*(Math.cos(event.time*0.8+i*3.14*1/4)) + Math.sin(iPct)))*0.5+0.5;
		// touchNodes.nodes[i].y = Math.sin(i+event.time*Math.cos(iPct*5/4 + 0.1*iPct*5/4*(Math.sin(event.time*0.8+i*3.14)) + Math.sin(iPct*3/4)))*0.5+0.5;

		// // cool wobbles
		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi+event.time*(Math.cos(iPctPi*0.5)*0.25+0.5) +Math.cos(
		// 	Math.sin(iPctPi*3/2+event.time*iPctPi*1/3) )
		// );
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi+event.time*(Math.cos(iPctPi*0.5)*0.25+0.5) +Math.cos(
		// 	Math.sin(iPctPi*5/4+event.time*iPctPi*3/5) )
		// );

		// separated
		// var rFreq = 2;// * Math.sin(event.time);
		// var r = 1.0-iPct*0.2;//+0.6+0.4*Math.cos(rFreq*event.time);
		// var offX = Math.PI*2*Math.sin(iPctPi+event.time*0.0888)+Math.PI*2*Math.sin(-iPctPi+event.time*0.066);
		// var offY = Math.PI*2*Math.sin(iPctPi+event.time*0.1111)+Math.PI*2*Math.sin(-iPctPi+event.time*0.022);
		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi + event.time*0.3 + offX) * r;
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi + event.time*0.3 + offY) * r;


		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi+event.time+Math.cos(
		// 	Math.sin(iPctPi*3/2+event.time*iPctPi*1/3) + 0.1*Math.sin(iPct*3/2)*(Math.cos(event.time*0.8+i*3.14*1/4))  )
		//                                          );
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi+event.time+Math.cos(
		// 	Math.sin(iPctPi*5/4+event.time*iPctPi*12/9) + 0.1*Math.sin(iPct*5/4)*(Math.sin(event.time*0.8+i*3.14)) )
		//                                          );

		// console.log(touchNodes.nodes[i]);
		// console.log(event.time*(Math.sin(i*3/2+Math.sin(i+2))*0.5+0.5) + Math.PI * 5/8);
	}
	var v = this.makeVoronoi(touchNodes, 0.5, !showCreases);
}

</script>

</html>