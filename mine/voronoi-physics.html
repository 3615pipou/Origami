<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link href="../lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<style>
html, body {
	height:100%;
	width:100%;
	background-color: #EEE;
	margin:0px;
}
canvas[resize]{
	width:100%;
	height:86%;
}
</style>
</head>
<body>
	<canvas id="canvas" resize></canvas>
	<input type="file" id="files" style="display:none;">
	<div style="text-align:center;">
		<div class="btn-group" data-toggle="buttons">
			<label class="btn btn-lg btn-outline-secondary active">
				<input type="checkbox" id="show-creases-button" checked autocomplete="off"> Show Creases
			</label>
		</div>
		<a href="#" class="btn btn-lg btn-secondary" id="download-file">Download</a>
	</div>
</body>

<script type="text/javascript" src="../lib/d3.min.js"></script>
<script type="text/javascript" src="../lib/paper-full.min.js"></script>
<script type="text/javascript" src="../src/graph.js"></script>
<script type="text/javascript" src="../src/planarGraph.js"></script>
<script type="text/javascript" src="../src/creasePattern.js"></script>
<script type="text/javascript" src="../src/cp.paperjs.js"></script>
<script src="../lib/bootstrap/js/tether.min.js"></script>
<script src="../lib/jquery-3.2.1.slim.min.js"></script>
<script src="../lib/bootstrap/js/popper.min.js"></script>
<script src="../lib/bootstrap/js/bootstrap.min.js"></script>
<script src="../lib/bootstrap/js/ie10-viewport-bug-workaround.js"></script>
<!-- <script src="../lib/matter.min.js"></script> -->

<script src="../lib/matter.js"></script>
<script src="../lib/matter-attractors.min.js"></script>

<script>
var showCreases = true;
$('#show-creases-button').change(function() {
	var checked = $(this).prop('checked');
	showCreases = checked;
	console.log($(this).prop('checked'));
	project.makeVoronoi(touchNodes, 0.5, !showCreases);
})
</script>

<!-- download svg blob -->
<script>
document.getElementById("download-file").addEventListener("click", function(e){
	e.preventDefault();
	var scale = 600 / project.cpMin;
	var svgBlob = project.cp.svg(scale);
	download(svgBlob, "creasepattern.svg");
});
function download(text, filename){
	var blob = new Blob([text], {type: "image/svg+xml"});
	var url = window.URL.createObjectURL(blob);
	var a = document.createElement("a");
	a.href = url;
	a.download = filename;
	a.click();
}
</script>

<script type="text/javascript">
var voronoiAlgorithm; // global D3 algorithm implementation



var project = new OrigamiPaper("canvas");
project.updateWeights(0.005, 0.0025);
project.setPadding();
project.updateWeights(0.005, 0.0025);

var touchNodes = new PlanarGraph();
var touchNodesCircles = [];
var touchNodesLayer

var dragOn = false;
var selectedNode = undefined;

Matter.use(
  'matter-attractors' // PLUGIN_NAME
);

var Engine = Matter.Engine,
    Render = Matter.Render,
    Runner = Matter.Runner,
    Body = Matter.Body,
    Common = Matter.Common,
    Composites = Matter.Composites,
    MouseConstraint = Matter.MouseConstraint,
    Mouse = Matter.Mouse,
    World = Matter.World,
    Bodies = Matter.Bodies;


var engine = Engine.create();
var world = engine.world;

// Engine.run(engine);

var runner = Runner.create();
Runner.run(runner, engine);

  // create renderer
// var render = Render.create({
// element: document.body,
// engine: engine,
// 	options: {
// 	  width: 1,
// 	  height: 1
// 	}
// });

// Render.run(render);

  // var runner = Runner.create();
  // Runner.run(runner, engine);

// var box1 = Bodies.rectangle(0,0,1,1);
var circles = [];
// var circle1 = Bodies.circle(Math.random(),Math.random(),0.02);
// var circle2 = Bodies.circle(Math.random(),Math.random(),0.02);
// var circle3 = Bodies.circle(Math.random(),Math.random(),0.02);

  // add bodies
world.bodies = [];
world.gravity.scale = 0;

engine.timing.timeScale = .1;


var centerGravity = Bodies.circle(0.5, 0.5, 0.001,
  {
    isStatic: true,
    plugin: {
      attractors: [
        function(bodyA, bodyB) {
          return {
            x: (bodyA.position.x - bodyB.position.x) * 1e-7,
            y: (bodyA.position.y - bodyB.position.y) * 1e-7,
          };
        }
      ]
    }
  }
);

World.add(world, centerGravity);


for (var i = 0; i < 3; i += 1) {

	var particleOptions = {
	    mass: Common.random(.001, .0015),
	    frictionAir: 0,
	    plugin: {
	      attractors: [
	        // there is a built in helper function for Newtonian gravity!
	        // you can find out how it works in index.js
	        MatterAttractors.Attractors.gravity
	      ]
	    }
	  };

	var body = Composites.softBody(Math.random(), Math.random(), 1, 1, 0, 0, false, 0.3, particleOptions);

	// var body = Bodies.circle(
	//   Math.random(), 
	//   Math.random(),
	//   0.3,
	//   particleOptions
	// );

	circles.push(body);

	// var speed = 0.01;

	// Body.setVelocity(body, { 
	//   x: Common.random(-speed, speed), 
	//   y: Common.random(-speed, speed)
	// });

	World.add(world, body);
}


project.makeVoronoi = function(input, interpolation, hideCreaseMarks){
	var nodes = input.nodes.map(function(el){return el.values();});
	var v = voronoiAlgorithm( nodes );
	this.cp.clear();
	this.cp.nodes = [];
	this.cp.edges = [];
	this.cp.voronoi(v, interpolation);
	if(hideCreaseMarks === true){
		for(var i = this.cp.edges.length-1; i >= 0; i--){
			// if(this.cp.edges[i].orientation !== CreaseDirection.valley){
			if(this.cp.edges[i].orientation === CreaseDirection.mark || 
			   this.cp.edges[i].orientation === CreaseDirection.mountain){
				this.cp.removeEdge(this.cp.edges[i]);
			}
		}
	}
	this.updateWeights(0.015, 0.0075);
	this.draw();
	touchNodesLayer.activate();
	touchNodesLayer.removeChildren();
	// faces
	var cells = voronoiAlgorithm.polygons(nodes);
	for(var c = 0; c < cells.length; c++){
		var segments = [];
		for(var e = 0; e < cells[c].length; e++){
			var point = new XY(cells[c][e][0], cells[c][e][1]);
			segments.push(point);
		}
		var face = new this.scope.Path({segments:segments,closed:true});
		var color = 100 + 200 * c/cells.length;
		face.fillColor = {gray:0.0, alpha:0.05};
		var site = new XY(cells[c].data[0], cells[c].data[1]);
		face.scale(.5, site);
	}

	// site nodes
	touchNodesCircles = [];
	for(var i = 0; i < touchNodes.nodes.length; i++){
		var nodeCircle = new this.scope.Shape.Circle({ radius: 0.01, fillColor:this.style.valley.strokeColor});
		touchNodesCircles.push(nodeCircle);
		nodeCircle.position = touchNodes.nodes[i];
	}
	return v;
}

project.reset = function(){
	this.cp.clear();
	// this.cp.rectangle(1.3,1);
	this.draw();
	voronoiAlgorithm = d3.voronoi().extent( this.cp.boundingBox_array() );

	if(touchNodesLayer !== undefined){ touchNodesLayer.removeChildren(); }
	touchNodesLayer = new this.scope.Layer();

	// touchNodes.newPlanarNode(0.867921, 0.712489);
	// touchNodes.newPlanarNode(0.781352, 0.891531);
	// touchNodes.newPlanarNode(0.885629, 0.517707);
	for(var i = 0; i < 3; i++){
		touchNodes.newPlanarNode(Math.random(), Math.random());
	}

	var v = this.makeVoronoi(touchNodes, 0.5, !showCreases);
	console.log(v);
}
project.reset();

project.onResize = function(){
	voronoiAlgorithm = d3.voronoi().extent( this.cp.boundingBox_array() );
}

project.onMouseDown = function(event){
}
project.onMouseUp = function(event){ 
}
project.onMouseMove = function(event) {
}
project.onFrame = function(event){ 
	// console.log(event.time);
	for (var i = 0; i < touchNodes.nodes.length; i++){


		touchNodes.nodes[i].x = circles[i].bodies[0].position.x;
		touchNodes.nodes[i].y = circles[i].bodies[0].position.y;

		// touchNodes.nodes[i].x = (Math.sin(event.time*(Math.sin(i*3/2+Math.sin(i+2))*0.5+0.5) + Math.PI * 5/8))*0.5 + 0.5;
		// touchNodes.nodes[i].y = (Math.sin(event.time/12*3*(Math.sin(i*5/4+Math.sin(i+2))*0.5+0.5) + 1/12*Math.PI + 12/4))*0.5 + 0.5;
		// var iPct = i / touchNodes.nodes.length;
		// var iPctPi = i / touchNodes.nodes.length * Math.PI*2;

		// touchNodes.nodes[i].x = Math.cos(i+event.time*Math.cos(iPct*3/2 + 0.1*iPct*3/2*(Math.cos(event.time*0.8+i*3.14*1/4)) + Math.sin(iPct)))*0.5+0.5;
		// touchNodes.nodes[i].y = Math.sin(i+event.time*Math.cos(iPct*5/4 + 0.1*iPct*5/4*(Math.sin(event.time*0.8+i*3.14)) + Math.sin(iPct*3/4)))*0.5+0.5;

		// // cool wobbles
		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi+event.time*(Math.cos(iPctPi*0.5)*0.25+0.5) +Math.cos(
		// 	Math.sin(iPctPi*3/2+event.time*iPctPi*1/3) )
		// );
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi+event.time*(Math.cos(iPctPi*0.5)*0.25+0.5) +Math.cos(
		// 	Math.sin(iPctPi*5/4+event.time*iPctPi*3/5) )
		// );

		// separated
		// var rFreq = 2;// * Math.sin(event.time);
		// var r = 1.0-iPct*0.2;//+0.6+0.4*Math.cos(rFreq*event.time);
		// var offX = Math.PI*2*Math.sin(iPctPi+event.time*0.0888)+Math.PI*2*Math.sin(-iPctPi+event.time*0.066);
		// var offY = Math.PI*2*Math.sin(iPctPi+event.time*0.1111)+Math.PI*2*Math.sin(-iPctPi+event.time*0.022);
		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi + event.time*0.3 + offX) * r;
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi + event.time*0.3 + offY) * r;


		// touchNodes.nodes[i].x = 0.5+0.5*Math.cos(iPctPi+event.time+Math.cos(
		// 	Math.sin(iPctPi*3/2+event.time*iPctPi*1/3) + 0.1*Math.sin(iPct*3/2)*(Math.cos(event.time*0.8+i*3.14*1/4))  )
		//                                          );
		// touchNodes.nodes[i].y = 0.5+0.5*Math.sin(iPctPi+event.time+Math.cos(
		// 	Math.sin(iPctPi*5/4+event.time*iPctPi*12/9) + 0.1*Math.sin(iPct*5/4)*(Math.sin(event.time*0.8+i*3.14)) )
		//                                          );

		// console.log(touchNodes.nodes[i]);
		// console.log(event.time*(Math.sin(i*3/2+Math.sin(i+2))*0.5+0.5) + Math.PI * 5/8);
	}
	var v = this.makeVoronoi(touchNodes, 0.5, !showCreases);
}

</script>

</html>